<!DOCTYPE html>
<html lang="en">
  <head>
    <title>A small introduction to three.js webgl [1]</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link rel="stylesheet" href="css/basic.css" />

    <script src="three.js"></script>
    <script src="js/Detector.js"></script>
    <script type="text/javascript">
      // Checks that your browser supports WebGL.
      if (!Detector.webgl) Detector.addGetWebGLMessage();

      var renderer = null;
      var scene = null;
      var camera = null;
      var sun = null;
      var earth = null;
      var moon = null;
      var earthOrbitAngle = 0;
      var earthRotationAngle = 0;
      var moonOrbitAngle = 0;
      var earthGroup = new THREE.Group();
      var moonGroup = new THREE.Group();
      var curTime = Date.now();
      var controls = null;
      var objects = [];


      // This function is called whenever the document is loaded
      function init() {
        // Get display canvas
        var canvas = document.getElementById("webglcanvas");
        console.log(canvas);

        // Create the Three.js renderer and attach it to our canvas
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        // Set the viewport size
        renderer.setSize(canvas.width, canvas.height);
        // Create a new Three.js scene

        // Floor
        //var floorHeight = 7000;
        //geometry = new THREE.SphereGeometry(floorHeight, 10, 6, 0, (Math.PI * 2), 0, 0.8);
        //geometry.applyMatrix( new THREE.Matrix4().makeTranslation(0, -floorHeight, 0) );

//        var floor_material = new THREE.MeshLambertMaterial( );

        scene = new THREE.Scene();
        //floorMesh = new THREE.Mesh( geometry, floor_material );
        //objects.push( floorMesh );
        //scene.add(floorMesh);

        // Add  a camera so we can view the scene
        camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 9000 );
        //scene.add( controls.getPlayer() );
        controls = new THREE.PointerLockControls( camera, 100, 30, true, objects );
//        scene.add(controls.getPlayer())

        // les textures des éléments
        // Create a texture-mapped cube and add it to the scene
        // First, create the texture map
        var mapUrl = "images/earth_atmos_2048.jpg";
        var map = new THREE.TextureLoader().load(mapUrl);

        // Now, create a Basic material; pass in the map
        //var material = new THREE.MeshPhongMaterial({ map: map });

        // Now, create a Phong material with a white specular highlight and pass in the map
        var material = new THREE.MeshPhongMaterial({
          map: map,
          specular: 0xffffff,
          shininess: 30,
        });

        // Create the cube geometry
        var geometry = new THREE.SphereGeometry(1, 32, 32);
        earth = new THREE.Mesh(geometry, material);
        earth.position.set(5, 5, -30);
        earth.rotation.x = Math.PI / 5;
        earth.rotation.y = Math.PI / 5;

        // Création de la sphère pour le soleil
        var sunGeometry = new THREE.SphereGeometry(3, 32, 32);
        const sunMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700 });
        sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(0, 0, -20);

        const moonGeometry = new THREE.SphereGeometry(1, 32, 32);
        var moonMaterial = new THREE.MeshPhongMaterial({
          map: new THREE.TextureLoader().load("images/moon_1024.jpg"),
        });
        moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(-4, -5, -20);
        moon.rotation.x = Math.PI / 5;
        moon.rotation.y = Math.PI / 5;

        earthGroup.add(earth);
        moonGroup.add(moon);
        earthGroup.add(moonGroup);

        scene.add(earthGroup);
        scene.add(sun);

     

        // Add a white point light
        light = new THREE.PointLight(0xffffff, 1.5);
        light.position.set(0, 0, 0);
        scene.add(light);

        light.castShadow = true;
        light.shadow.mapSize.width = 512; // default
        light.shadow.mapSize.height = 512; // default
        light.shadow.camera.near = 0.5; // default
        light.shadow.camera.far = 50;
      }

      // This function is called regularly to update the canvas webgl.
      function run() {
        // Ask to call again run
        requestAnimationFrame(run);

        // Render the scene
        render();

        // Calls the animate function if objects or camera should move
        animate();
      }

      // This function is called regularly to take care of the rendering.
      function render() {
        // Render the scene
        renderer.render(scene, camera);
      }

      // This function is called regularly to update objects.
      function animate() {
        camera.lookAt(earth.matrixWorld.getPosition());

        // Computes how time has changed since last display
        var now = Date.now();
        var deltaTime = now - curTime;
        curTime = now;
        var fracTime = deltaTime / 1000; // in seconds
        // Now we can move objects, camera, etc.
        // Example: rotation cube
        var angle = fracTime * Math.PI * 2;
        // Notez que l'axe y est l'axe "vertical" usuellement.
        earthGroup.rotation.y += angle / 365; // la terre tourne en 365 jours
        earth.rotation.y += angle; // et en un jour sur elle-même

        moonGroup.rotation.y += angle / 28; // la lune tourne en 28 jours autour de la terre
        moon.rotation.y += angle / 28; // et en 28 jours aussi sur elle-même pour faire face à la terre
      }
    </script>
  </head>
  <body>
    <div id="info">a first three.js example</div>
    <canvas
      id="webglcanvas"
      style="border: none; background-color: #000000"
      width="1000"
      height="800"
    ></canvas>
    <!-- We run the WebGL code at the end to be sure that the document is loaded.
      -->
    <script src="js/FPSConstrols.js"></script>
    <script src="js/pointerlock.js"></script>
    <script>
      function eventHandlers() {

        // Keyboard press handlers
        var onKeyDown = function ( event ) { event.preventDefault(); event.stopPropagation(); handleKeyInteraction(event.keyCode, true); };
        var onKeyUp = function ( event ) { event.preventDefault(); event.stopPropagation(); handleKeyInteraction(event.keyCode, false); };
        document.addEventListener( 'keydown', onKeyDown, false );
        document.addEventListener( 'keyup', onKeyUp, false );


      }

      // HANDLE KEY INTERACTION
      function handleKeyInteraction(keyCode, boolean) {
        var isKeyDown = boolean;

        switch(keyCode) {
          case 38: // up
          case 87: // w
            controls.movements.forward = boolean;
            break;

          case 40: // down
          case 83: // s
            controls.movements.backward = boolean;
            break;

          case 37: // left
          case 65: // a
            controls.movements.left = boolean;
            break;

          case 39: // right
          case 68: // d
            controls.movements.right = boolean;
            break;

          case 32: // space
            if (!isKeyDown) {
              controls.jump();
              console.log('jump')
            }
            break;

          case 16: // shift
            controls.walk(boolean);
            break;

          case 67: // crouch (CTRL + W etc destroys tab in Chrome!)
            controls.crouch(boolean);

        }
      }
    </script>
    <script>
      init();
      eventHandlers();
      run();
    </script>

  </body>
</html>
